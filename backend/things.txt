## Why MetaMask Sign-In (Signature Verification) Matters

Without MetaMask sign-in (signature verification), your backend cannot verify that a request is truly coming from the owner of a wallet address. This creates several security risks:

### 1. Impersonation Risk
- Anyone can send requests to your API using any wallet address, even if they do not own that wallet.
- The backend, without signature verification, cannot distinguish between the real wallet owner and an attacker.

### 2. Exploitation Scenarios
- Attackers can claim signup bonuses or credits by pretending to be new wallets.
- They can spend credits or access data as another user by submitting someone else’s wallet address.
- Any endpoint that relies on wallet ownership can be abused.

### 3. Real-World Example
- If your API allows buying credits or accessing premium features by wallet address, a hacker could use another person’s address to get those features or drain their credits.

### 4. Solution: Signature Verification
- MetaMask sign-in requires the user to sign a unique message (nonce) with their wallet.
- The backend verifies the signature, proving the user controls the wallet.
- This prevents impersonation and ensures only the true wallet owner can act as that wallet.

---

## Implementation & Integration Notes (moved from README)

### Atomic credit deduction (implementation detail)
- The backend uses an atomic DB update to deduct a credit only when available to prevent race conditions from concurrent requests.
- Example (Mongo/Mongoose):
	- `Wallet.findOneAndUpdate({ wallet, credits: { $gte: 1 } }, { $inc: { credits: -1 } }, { new: true })`.
- On downstream failure (enrichment or AI generation) the system refunds with:
	- `Wallet.findOneAndUpdate({ wallet }, { $inc: { credits: 1 } })`.

### Gemini AI integration
- `GEMINI_API_KEY` enables live opener generation via `@google/genai`.
- `GEMINI_MODEL` can be set to override the default model.
- In development (no key), the backend returns a mock opener to avoid external calls.

### FullEnrich integration
- `FULLENRICH_API_KEY` enables live profile enrichment.
- Optional env: `FULLENRICH_BASE_URL`, `FULLENRICH_TIMEOUT_MS`, `FULLENRICH_POLL_INTERVAL_MS`.
- Use the FullEnrich test contact (`https://www.linkedin.com/in/demoge/`) when developing to avoid consuming credits.

### Frontend flow (expanded)
- Connect wallet (MetaMask) → get `walletAddress`.
- Fetch initial data: `/api/credits/:wallet`, `/api/badges/:wallet`, `/api/history/:wallet`.
- Submit LinkedIn URL to `/api/search` with `linkedinUrl` and optional `wallet`.
- On 402, call your purchase flow then POST `/api/buy-credits` after confirmation.

### Production suggestions (moved out of README)
- Protect admin endpoints; require signature-based auth for wallet-sensitive actions.
- Persist audit logs for credit-deduction events; use Winston or another structured logger.
- Configure CORS to only allow your frontend origin and enable HTTPS.

